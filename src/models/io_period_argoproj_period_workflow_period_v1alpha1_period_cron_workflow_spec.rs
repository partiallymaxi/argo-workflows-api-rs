/*
 * Argo Workflows API
 *
 * Argo Workflows is an open source container-native workflow engine for orchestrating parallel jobs on Kubernetes. For more information, please see https://argo-workflows.readthedocs.io/en/latest/
 *
 * The version of the OpenAPI document: VERSION
 * 
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

/// IoPeriodArgoprojPeriodWorkflowPeriodV1alpha1PeriodCronWorkflowSpec : CronWorkflowSpec is the specification of a CronWorkflow
#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct IoPeriodArgoprojPeriodWorkflowPeriodV1alpha1PeriodCronWorkflowSpec {
    /// ConcurrencyPolicy is the K8s-style concurrency policy that will be used
    #[serde(rename = "concurrencyPolicy", skip_serializing_if = "Option::is_none")]
    pub concurrency_policy: Option<String>,
    /// FailedJobsHistoryLimit is the number of failed jobs to be kept at a time
    #[serde(rename = "failedJobsHistoryLimit", skip_serializing_if = "Option::is_none")]
    pub failed_jobs_history_limit: Option<i32>,
    /// Schedule is a schedule to run the Workflow in Cron format. Deprecated, use Schedules
    #[serde(rename = "schedule", skip_serializing_if = "Option::is_none")]
    pub schedule: Option<String>,
    /// v3.6 and after: Schedules is a list of schedules to run the Workflow in Cron format
    #[serde(rename = "schedules", skip_serializing_if = "Option::is_none")]
    pub schedules: Option<Vec<String>>,
    /// StartingDeadlineSeconds is the K8s-style deadline that will limit the time a CronWorkflow will be run after its original scheduled time if it is missed.
    #[serde(rename = "startingDeadlineSeconds", skip_serializing_if = "Option::is_none")]
    pub starting_deadline_seconds: Option<i32>,
    #[serde(rename = "stopStrategy", skip_serializing_if = "Option::is_none")]
    pub stop_strategy: Option<Box<models::IoPeriodArgoprojPeriodWorkflowPeriodV1alpha1PeriodStopStrategy>>,
    /// SuccessfulJobsHistoryLimit is the number of successful jobs to be kept at a time
    #[serde(rename = "successfulJobsHistoryLimit", skip_serializing_if = "Option::is_none")]
    pub successful_jobs_history_limit: Option<i32>,
    /// Suspend is a flag that will stop new CronWorkflows from running if set to true
    #[serde(rename = "suspend", skip_serializing_if = "Option::is_none")]
    pub suspend: Option<bool>,
    /// Timezone is the timezone against which the cron schedule will be calculated, e.g. \"Asia/Tokyo\". Default is machine's local time.
    #[serde(rename = "timezone", skip_serializing_if = "Option::is_none")]
    pub timezone: Option<String>,
    /// v3.6 and after: When is an expression that determines if a run should be scheduled.
    #[serde(rename = "when", skip_serializing_if = "Option::is_none")]
    pub when: Option<String>,
    #[serde(rename = "workflowMetadata", skip_serializing_if = "Option::is_none")]
    pub workflow_metadata: Option<Box<models::IoPeriodK8sPeriodApimachineryPeriodPkgPeriodApisPeriodMetaPeriodV1PeriodObjectMeta>>,
    #[serde(rename = "workflowSpec")]
    pub workflow_spec: Box<models::IoPeriodArgoprojPeriodWorkflowPeriodV1alpha1PeriodWorkflowSpec>,
}

impl IoPeriodArgoprojPeriodWorkflowPeriodV1alpha1PeriodCronWorkflowSpec {
    /// CronWorkflowSpec is the specification of a CronWorkflow
    pub fn new(workflow_spec: models::IoPeriodArgoprojPeriodWorkflowPeriodV1alpha1PeriodWorkflowSpec) -> IoPeriodArgoprojPeriodWorkflowPeriodV1alpha1PeriodCronWorkflowSpec {
        IoPeriodArgoprojPeriodWorkflowPeriodV1alpha1PeriodCronWorkflowSpec {
            concurrency_policy: None,
            failed_jobs_history_limit: None,
            schedule: None,
            schedules: None,
            starting_deadline_seconds: None,
            stop_strategy: None,
            successful_jobs_history_limit: None,
            suspend: None,
            timezone: None,
            when: None,
            workflow_metadata: None,
            workflow_spec: Box::new(workflow_spec),
        }
    }
}

